
\appendix
\appendixpage
\chapter{JET Language}
\label{appendix:jetLanguage}
\section{Grammar}
\section{Inline Haskell Example}
\begin{minipage}{\linewidth}
    \begin{lstlisting}[caption = Example of initial inline haskell code, label=lst:inlineHaskellCode, language=Haskell]
    {
    import qualified Data.Map as M
    import AbsAd
    
    data ContextKey = Ret | Func Ident [Type] | Var Ident
        deriving (Eq, Ord, Show, Read)
    
    newtype Context = Context (Type, JetContextMap (Ident, [Type]) Type, JetContextMap Ident Type)
        deriving (Eq, Ord, Show, Read)
    
    instance JetContextBase Context where
        emptyContext = Context (TNNone, emptyContext, emptyContext)
        newBlock (Context (t, f, v) = Context (t, newBlock f, newBlock v)
    
    instance JetContext Context ContextKey Type where
        lookupContext Ret (Context (r, _, _, _, _)) = return r
        lookupContext (Func ident ts) (Context (_, _, f, _, _)) = lookupContext (ident, ts) f
        lookupContext (Var ident) (Context (_, _, _, v, _)) = lookupContext ident v
        expandContext Ret t (Context (_, p, f, v, s)) = return (Context (t, p, f, v, s))
        expandContext (Func ident ts) t (Context (rt, p, f, v, s)) = do
            f' <- expandContextIf (\(i, t) (JetContextMap (b:bs)) -> null (filter (\(i', t') -> i == i') (M.keys b))) (ident, ts) t f
            return (Context (rt, p, f', v, s))
        expandContext (Var ident) t (Context (rt, p, f, v, s)) = do
            v' <- expandContext ident t v
            return (Context (rt, p, f, v', s))
    
    makeCheckError e t1 t2 = "Type error"
    makeCheckErrorList _ _ _ = "Type error"
    makeInferError _ _ = "Type error"
    }
    \end{lstlisting}
\end{minipage}

\chapter{Witness Languages}
\label{appendix:witnessLanguages}
\section{Ad Language}
\subsection{AST}
\begin{lstlisting}[language=Haskell]
newtype Ident = Ident String
data Program = Prog ProcDecl

data FuncDecl = FDecl Ident [VarDecl] TypeName [Decl] [Stmnt]

data ProcDecl = PDecl Ident [VarDecl] [Decl] [Stmnt]

data VarDecl = VDecl Ident TypeName

data Decl = DFunc FuncDecl | DProc ProcDecl | DVar VarDecl

data Stmnt
    = SNull
    | SPrint Expr
    | SAssign Ident Expr
    | SIf Expr [Stmnt] [Stmnt]
    | SWhile Expr [Stmnt]
    | SBlock [Decl] [Stmnt]
    | SCall Ident [Expr]
    | SReturn Expr

data Expr
    = EInt Integer
    | ETrue
    | EFalse
    | EVar Ident
    | ECall Ident [Expr]
    | ENeg Expr
    | ENot Expr
    | EMul Expr Expr
    | EAnd Expr Expr
    | EAdd Expr Expr
    | EOr Expr Expr
    | EEq Expr Expr
    | ELT Expr Expr

data TypeName = TNBool | TNInt | TNNone
\end{lstlisting}

\subsection{Type Rules}
The definition of $\Gamma$ for the Ad language is a 5-tuple of the form $(\tau_{ret}, P, F, V, T)$, where $\tau_{ret}$ is the return type of the current subprogram, $P$ is the name-space of procedures, $F$ is the name-space for functions, $V$ is the name space for variables, $T$ is the name-space for types.
The name-spaces $P$, $F$, $V$ are block structured whereas $T$ is not, therefore $newblock(\Gamma)$ is really $(\tau_{ret}, newblock(P),newblock(F), newblock(V), T)$
\subsubsection{Statements}
\begin{figure}[H]
    \begin{center}
        \LeftLabel{AdNullT}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash \lfloor null \rfloor\ valid$}
        \DisplayProof{}
        \label{fig:adnullt}
        \ 
        \LeftLabel{AdPrintT}
        \AxiomC{$\Gamma \vdash e : \tau$}
        \UnaryInfC{$\Gamma \vdash \lfloor print\ e\rfloor\ valid$}
        \DisplayProof{}
        \label{fig:adprintt}
    \end{center}
    \caption{Type rules for statements in the Ad language}
    \label{fig:adStmnts}
\end{figure}

\subsubsection{Expressions}
\begin{figure}[H]
    \begin{center}
        \LeftLabel{AdTrueT}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash true : Bool$}
        \DisplayProof{}
        \label{fig:adtruet}
        \ 
        \LeftLabel{AdFalseT}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash false : Bool$}
        \DisplayProof{}
        \label{fig:adfalset}

        \ \\
        \LeftLabel{AdInt}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash n : Int$}
        \DisplayProof{}
        \label{fig:adintt}
        \ 
        \LeftLabel{AdNot}
        \AxiomC{$\Gamma \vdash e : Bool$}
        \UnaryInfC{$\Gamma \vdash not\ e : Bool$}
        \DisplayProof{}
        \ 
        \LeftLabel{AdNeg}
        \AxiomC{$\Gamma \vdash e : Int$}
        \UnaryInfC{$\Gamma \vdash neg\ e : Int$}
        \DisplayProof{}

        \ \\
        \LeftLabel{AdAnd}
        \AxiomC{$\Gamma \vdash e_1 : Bool$}
        \AxiomC{$\Gamma \vdash e_2 : Bool$}
        \BinaryInfC{$\Gamma \vdash e_1\ and\ e_2 : Bool$}
        \DisplayProof{}

        \ \\
        \LeftLabel{AdMul}
        \AxiomC{$\Gamma \vdash e_1 : Int$}
        \AxiomC{$\Gamma \vdash e_2 : Int$}
        \BinaryInfC{$\Gamma \vdash e_1 * e_2 : Int$}
        \DisplayProof{}

        \ \\
        \LeftLabel{AdOr}
        \AxiomC{$\Gamma \vdash e_1 : Bool$}
        \AxiomC{$\Gamma \vdash e_2 : Bool$}
        \BinaryInfC{$\Gamma \vdash e_1\ or\ e_2 : Bool$}
        \DisplayProof{}

        \ \\
        \LeftLabel{AdAdd}
        \AxiomC{$\Gamma \vdash e_1 : Int$}
        \AxiomC{$\Gamma \vdash e_2 : Int$}
        \BinaryInfC{$\Gamma \vdash e_1 + e_2 : Int$}
        \DisplayProof{}

        \ \\
        \LeftLabel{AdEq}
        \AxiomC{$\Gamma \vdash e_1 : \tau$}
        \AxiomC{$\Gamma \vdash e_2 : \tau$}
        \BinaryInfC{$\Gamma \vdash e_1 = e_2 : Bool$}
        \DisplayProof{}
        \ 
        \LeftLabel{AdLT}
        \AxiomC{$\Gamma \vdash e_1 : Int$}
        \AxiomC{$\Gamma \vdash e_2 : Int$}
        \BinaryInfC{$\Gamma \vdash e_1 < e_2 : Bool$}
        \DisplayProof{}
    \end{center}
    \label{fig:adExprs}
    \caption{Type rules for expressions in the Ad language}
\end{figure}

\section{Simply Typed Lambda Calculus}
$\Gamma$ in the Simply Typed Lambda Calculus is simply just a single name-space containing variables.
\subsection{AST}
\begin{lstlisting}[language=Haskell]
data Id = Id String

data Literal 
    = LitInt Integer
    | LitBool Bool

data Expr 
    = Var Id
    | Lit Literal
    | App Expr Expr
    | Lam Id Type Expr
    | If Expr Expr Expr
    | Fix Expr
    | Pred Expr
    | ESucc Expr
    | Iszero Expr

data Type
    = TInt
    | TBool
    | TFun Type Type

\end{lstlisting}

\subsection{Type Rules}

\begin{figure}[H]
    \begin{center}
        \LeftLabel{STLCBool: }
        \RightLabel{$[b \in \{true, false\}]$}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash b : Bool$}
        \DisplayProof{}
        \ \\\ \\
        \LeftLabel{STLCInt: }
        \RightLabel{$[n \in \mathbb{N}]$}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash n : Int$}
        \DisplayProof{}
        \ \\\ \\
        \LeftLabel{STLCVar: }
        \RightLabel{$[\tau = lookup(x, \Gamma)]]$}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash n : \tau$}
        \DisplayProof{}
        \ \\\ \\
        \LeftLabel{STLCLam: }
        \AxiomC{$expandContext(x, \sigma, newblock(\Gamma)) \vdash e : \tau$}
        \UnaryInfC{$\Gamma \vdash (\lambda x : \sigma\ .\ e) : (\sigma \rightarrow \tau)$}
        \DisplayProof{}

        \ \\\ \\
        \LeftLabel{STLCApp: }
        \AxiomC{$\Gamma \vdash e_1 : \sigma \rightarrow \tau$}
        \AxiomC{$\Gamma \vdash e_2 : \sigma$}
        \BinaryInfC{$\Gamma \vdash e_1\ e_2 : \tau$}
        \DisplayProof{}

        \ \\\ \\
        \LeftLabel{STLCPred: }
        \AxiomC{$\Gamma \vdash e : Int$}
        \UnaryInfC{$\Gamma \vdash pred\ e : Int$}
        \DisplayProof{}
        \ 
        \LeftLabel{STLCSucc: }
        \AxiomC{$\Gamma \vdash e : Int$}
        \UnaryInfC{$\Gamma \vdash succ\ e : Int$}
        \DisplayProof{}

        \ \\\ \\
        \LeftLabel{STLCIszero: }
        \AxiomC{$\Gamma \vdash e : Int$}
        \UnaryInfC{$\Gamma \vdash iszero\ e : Bool$}
        \DisplayProof{}
        \ 
        \LeftLabel{STLCFix: }
        \AxiomC{$\Gamma \vdash e : \tau \rightarrow \tau$}
        \UnaryInfC{$\Gamma \vdash fix\ e : \tau$}
        \DisplayProof{}

        \ \\\ \\
        \LeftLabel{STLCIf: }
        \AxiomC{$\Gamma \vdash e_1 : Bool$}
        \AxiomC{$\Gamma \vdash e_2 : \tau$}
        \AxiomC{$\Gamma \vdash e_3 : \tau$}
        \TrinaryInfC{$\Gamma \vdash if\ e_1\ then\ e_2\ else\ e_3 : \tau$}
        \DisplayProof{}
    \end{center}
    \label{fig:stlcTyperules}
    \caption{Type rules for the simply typed lambda calculus}
\end{figure}

\subsection{JET Specification}
\begin{lstlisting}[language=Haskell]
{
import Lang.Ast

type Context = JetContextMap Id Type
makeCheckError _ _ _ = "Type Error"
makeInferError _ _ = "Type Error"
}

typerule TLitBool <- (Literal LitBool b) : TBool return {return ()};
typerule TLitInt <- (Literal LitInt n) : TInt return {return ()};

typerule TExprVar <- if {t <- lookupContext var ctx} then (Expr Var var) : t return {return ()};
typerule TExprLit <- if {ctx} |- (Literal k) : t then (Expr Lit k) : t return {return ()} ;
typerule TExprIf <- if {ctx} |- (Expr ep) : TBool, {ctx} |- (Expr et) : t, {ctx} |- (Expr ef) : t then (Expr If ep et ef) : t return {return ()};
typerule TExprApp <- if {ctx} |- (Expr e1) : TFun t1 t2, {ctx} |- (Expr e2) : t1 then (Expr App e1 e2) : t2 return {return ()};
typerule TExprLam <- if {=<< expandContext var t1 (newBlock ctx)} |- (Expr e) : t2 then (Expr Lam var t1 e) : TFun t1 t2 return {return ()};
typerule TExprFix <- if {ctx} |- (Expr e) : TFun t1 t2, {if t1 == t2 then return () else fail "Type error"} then (Expr Fix e) : t1 return {return ()};
typerule TExprPred <- if {ctx} |- (Expr e) : TInt then (Expr Pred e) : TInt return {return ()};
typerule TExprSucc <- if {ctx} |- (Expr e) : TInt then (Expr ESucc e) : TInt return {return ()};
typerule TExprIszero <- if {ctx} |- (Expr e) : TInt then (Expr Iszero e) : TBool return {return ()};
\end{lstlisting}

\chapter{Haskell Modules}
\label{appendix:modules}
\section{Jet Context Base}
\begin{lstlisting}[language=Haskell]
class JetContextBase t where
    emptyContext :: t
    newBlock :: t -> t
\end{lstlisting}
\section{Jet Context Relational}
\begin{lstlisting}[language=Haskell]
class JetContextBase r => JetContext r k t where
    lookupContext :: Ord k => k -> r -> JetError t
    expandContext :: Ord k => k -> t -> r -> JetError r
    expandContextIf :: Ord k => (k -> r -> Bool) -> k -> t -> r -> JetError r
\end{lstlisting}
\subsection{Jet Context Map}
\begin{lstlisting}[language=Haskell]
instance JetContextBase (JetContextMap a b) where
    emptyContext = JetContextMap [M.empty]
    newBlock (JetContextMap blocks) = JetContextMap (M.empty : blocks)

instance JetContext (JetContextMap a b) a b where
    lookupContext key (JetContextMap blocks) = maybe2Error "Lookup error" $ M.lookup key (M.unions blocks)
    expandContext key t (JetContextMap (block:blocks)) = do
        block' <- insertUnique key t block
        return (JetContextMap (block':blocks))
    expandContextIf predicate key t ctx = 
        if predicate key ctx then expandContext key t ctx
        else fail "Predicate check failed"
\end{lstlisting}
\section{Jet Error Monad}
\begin{lstlisting}[language=Haskell]
module JetErrorM where

import Control.Monad
import Control.Monad.Fail

data JetError a = Succ a | Fail String deriving (Show, Read, Eq, Ord)

instance Functor JetError where
    fmap = liftM

instance Applicative JetError where
    pure = Succ
    (<*>) = ap

instance Monad JetError where
    return = pure
    fail = Fail
    Succ a >>= f = f a
    Fail s >>= _ = Fail s

instance MonadFail JetError where
    fail = Fail

maybe2Error :: String -> Maybe a -> JetError a
maybe2Error s Nothing = Fail s
maybe2Error _ (Just a) = Succ a
\end{lstlisting}