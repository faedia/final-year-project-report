\appendix

\chapter{JET Language}
\label{appendix:jetLanguage}
\section{Grammar}

\chapter{Witness Languages}
\label{appendix:witnessLanguages}
\section{Ad Language}
The Ad language is a test case language to express the features that the tool can generate code for.
It is a simple imperative language.
\subsection{AST}
\begin{lstlisting}
newtype Ident = Ident String
data Program = Prog FuncDecl

data FuncDecl = FDecl Ident [VarDecl] TypeName Block

data ProcDecl = PDecl Ident [VarDecl] Block

data VarDecl = VDecl Ident TypeName

data Block = Blck [Decl] [Stmnt]

data Decl = DFunc FuncDecl | DProc ProcDecl | DVar VarDecl

data Stmnt
    = SNull
    | SPrint Expr
    | SAssign Ident Expr
    | SIf Expr [Stmnt] [Stmnt]
    | SWhile Expr [Stmnt]
    | SBlock Block
    | SCall Ident [Expr]
    deriving (Eq, Ord, Show, Read)

data Expr
    = EInt Integer
    | ETrue
    | EFalse
    | ECall Ident [Expr]
    | ENeg Expr
    | ENot Expr
    | EMul Expr Expr
    | EAnd Expr Expr
    | EAdd Expr Expr
    | EOr Expr Expr
    | EEq Expr Expr
    | ELT Expr Expr

data TypeName = TNBool | TNInt
\end{lstlisting}

\subsection{Type Rules}
\subsubsection{Statements}
\begin{figure}[H]
    \begin{prooftree}
        \LeftLabel{AdNullT}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash \lfloor null \rfloor\ valid$}
    \end{prooftree}
    \caption{Type rule for null statement}
    \label{fig:adnullt}
\end{figure}

\subsubsection{Expressions}
\begin{figure}[H]
    \begin{prooftree}
        \LeftLabel{AdTrueT}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash true : TBool$}
    \end{prooftree}
    \caption{Type rule for true literal expression}
    \label{fig:adtruet}
\end{figure}

\section{Simply Typed Lambda Calculus}
\subsection{AST}
\begin{lstlisting}
data Id = Id String

data Literal 
    = LitInt Int
    | LitBool bool

data Expr 
    = Var Id
    | Lit Literal
    | App Expr Expr
    | Lam Id Type Expr

data Type
    = TInt
    | TBool
    | TFun Type Type
\end{lstlisting}

\subsection{Type Rules}
\begin{figure}[H]
    \begin{prooftree}
        \LeftLabel{STLCBoolean: }
        \RightLabel{$[b \in \{true, false\}]$}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash b : Bool$}
    \end{prooftree}
    \caption{Type rule for boolean literal}
\end{figure}

\begin{figure}[H]
    \begin{prooftree}
        \LeftLabel{STLCInteger: }
        \RightLabel{$[n \in \mathbb{N}]$}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash n : Integer$}
    \end{prooftree}
    \caption{Type rule for integer literal}
\end{figure}

\begin{figure}[H]
    \begin{prooftree}
        \LeftLabel{STLCVariable: }
        \RightLabel{$[n : \tau \in \Gamma]$}
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash n : \tau$}
    \end{prooftree}
    \caption{Type rule for variable}
\end{figure}

\begin{figure}[H]
    \begin{prooftree}
        \LeftLabel{STLCLambda: }
        \AxiomC{$\Gamma, x:\sigma \vdash e : \tau$}
        \UnaryInfC{$\Gamma \vdash (\lambda x : \sigma\ .\ e) : (\sigma \rightarrow \tau)$}
    \end{prooftree}
    \caption{Type rule for lambda abstraction}
\end{figure}

\begin{figure}[H]
    \begin{prooftree}
        \LeftLabel{STLCApplication: }
        \AxiomC{$\Gamma \vdash e_1 : \sigma \rightarrow \tau$}
        \AxiomC{$\Gamma \vdash e_2 : \sigma$}
        \BinaryInfC{$\Gamma \vdash e_1\ e_2 : \tau$}
    \end{prooftree}
    \caption{Type rule for function application}
\end{figure}