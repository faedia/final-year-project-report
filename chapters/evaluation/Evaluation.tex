\chapter{Evaluation}
Given all of the features and type rule patterns we have discussed in \autoref{chap:Method} we can successfully type check both of our witness languages.
As per the aims given in \todo{autoref to aims}, we have discussed how to type check all but user defined types.
The full type specification in JET along with the natural deduction rules that we are implementing in our JET specification can also be seen in \autoref{appendix:witnessLanguages}.
While we have not discussed how to type check user defined types and record types, the JET specification for the Ad language does support these language features and does successfully type check them.
We did not discuss these type rules because there are no other features in the language that allow for a better representation of user defined types and record types than the representation that can be seen in the JET specification of the Ad language.
Both of our example languages have varying differing paradigms and language structure meeting one of our first main criteria of the project which was to be able type check simple programming languages from different paradigms.
The first of our languages, Ad was a small imperative block structured language which had variable, function and procedures along with a few primitive statements and expressions.
Where as STLC was a functional programming language which allowed for the use of functions as first class citizens along with higher order functions.
These two languages represent two main paradigms in programming languages and provide a base from which to implement other features in the future which would allow the extension of the type systems in these languages.
The type system features that could be added to these languages are, in brief, for Ad the use of extending record type to have the ability of subtyping and also implementing full object orientations; and in STLC the addition of recursive types\cite{pierce2002types,cardelli1996type} and polymorphic types\cite{Cardelli:1985:UTD:6041.6042}.
While these features are were not a requirement, they were mentioned as possible end goals that a full tool (JET is currently still a prototype) would need to support, otherwise there would be too many languages that JET would not support, therefore JET would  only be useful to generate code for simple and small languages.  

\section{Language Structure and Extensions}
One of the major short comings of JET is the representation of the context, both how it is defined and used throughout a given type system.
As mentioned in ?? \todo{ref to typical}, I think the representation of the context in typical is one of the best, it gives the user the ability to customise the type system as they wish but also provides a notation that is intuitive and easy to use.
We tried, as much as possible to make the definition of the type classes, used to define the contexts, as easy to use as possible and to help give the user an idea of what information may be required to build a specification in JET.
However a nicer notation for defining namespaces would most likely make the tool easier to use than it is in its current form, currently you have to write a fair amount of Haskell in order to get the context to act as required.
The inclusion of the predefined instance of the type class for \texttt{JetContextMap} does help provide a base for how the user will define their namespaces.
The lack of language support for functions defined by the Haskell type class reduces the usability of the tool.
This could be fixed by adding extra statements in the language.
For example is we were to attempt to lookup an item in the context in STLC, instead of writing the premise using inline haskell as \texttt{\{t <- lookupContext var ctx\}}.
We could instead have a piece of syntax in JET that encodes this meaning, for example we could have a grammar rule that has a keyword lookup and takes an item to lookup and a context to lookup withing, an example BNF grammar rule can be seen in \autoref{fig:LookupBNF}.
Using this grammar rule the type premise would be rewritten as \texttt{var lookup context : t}.
This would then be generated into the code that appeared in the initial type premise.

\begin{figure}[]
    \centering
    \begin{grammar}
        <TypePremise> ::= \dots \alt <Identifier> `lookup' <Identifier> `:' <Identifier>
    \end{grammar}
    \caption{}
    \label{fig:LookupBNF}
\end{figure}

I have mentioned that we can type check user defined types.
This is true, however, it requires excessive use of user defined Haskell functions, and also takes advantages of how the language is structured and how we generate the output code.
Using odd side affects of the language design to get the required behavior is obviously leads to unintuitive and hard to read type rules.
Therefore, an area of future work to be performed, for JET specifically, would be to design and implement a notation that provides a more intuitive method of performing type checking for user defined types along with record types etc.
This would greatly improve the usability of the tool, making it easier to implement a type checker for a language with a type system involving user defined types.
Possibly even making it quite simple to type check object oriented language which is class of language that we have not discussed but in the current state would require similar type rules to the ones in Ad for record types.

Unify algorithm and type reconstruction support and notation on how to specify how to unify types, will need to cite hindly milner type inference.

\section{Generated Code Structure}
Inefficient code generated in terms of monad statement order.

Inefficient ctx parameter position.

Generate quick check code for type classes to make sure they are implementing the semantics correct.

\section{Operational Semantics and Big Step Notation}
Long term extensions are to add ability to specify operation semantics.
