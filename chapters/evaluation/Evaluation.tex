\chapter{Evaluation}
Given all of the features and type rule patterns we have discussed in \autoref{chap:Method} we can successfully type check both of our witness languages.
As per the aims given in \todo{autoref to aims}, we have discussed how to type check all but user defined types.
The full type specification in JET along with the natural deduction rules that we are implementing in our JET specification can also be seen in \autoref{appendix:witnessLanguages}.
While we have not discussed how to type check user defined types and record types, the JET specification for the Ad language does support these language features and does successfully type check them.
We did not discuss these type rules because there are no other features in the language that allow for a better representation of user defined types and record types than the representation that can be seen in the JET specification of the Ad language.

\section{Language Structure and Extensions}
Support for context function directly in the grammar i.e x in y : t should generate t <- lookupContext x y
Also built in support for namespaces, generalise contexts a bit.

Language support for user defined types for user defined types.

Unify algorithm and type reconstruction support and notation on how to specify how to unify types, will need to cite hindly milner type inference.

\section{Generated Code Structure}
Inefficient code generated in terms of monad statement order.

Inefficient ctx parameter position.

Generate quick check code for type classes to make sure they are implementing the semantics correct.

\section{Operational Semantics and Big Step Notation}
Long term extensions are to add ability to specify operation semantics.