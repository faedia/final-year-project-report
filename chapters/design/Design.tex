\chapter{Design of the Notation}
\label{chap:Method}
Before we can generate type checking code we need to have a way of specifying the type system such that a program can read the given specification and generate the required code.
The way we will be specifying the the type system is through a domain specified language I have designed called \textit{JET Expresses Types} (JET).
The way type rules are written in JET are analogous to the natural deduction rules to define the type system.
This made the most sense as other parts of the compiler pipeline already have domain specific languages that are used to generate code.

In JET, rather than using the concrete syntax that is used in the natural deduction rules, we use the abstract syntax provided by the user to define the type rules.
We are using the abstract syntax for a number of reasons; the first reason is that we are going to be type checking input that has already been parsed therefore we are going to be type checking the abstract syntax tree and not the input of the concrete syntax.
The second reason, it is possible to type check an intermediate representation of a language.
Intermediate representations may only be represented through abstract syntax and have no concrete syntax, for example, Haskell's intermediate representation (known as core) is type checked during Haskell's compilation process\cite{marlow2004glasgow}.
Type rules in JET have a similar form to the natural deduction rules, such that there is a rule name followed by some judgments and then the consequent.
This provides a common way of representing type rules even if the way of writing the rules in JET uses an ASCII representation of the natural deduction rules.

The code we are generating is based off of the type checking and type inference algorithm described in \textcite{ranta2012implementing}.
This is because the algorithms described are simple, yet powerful enough to express common type rules, such as arithmetic expressions and also allow for the use of functions and variables.
It also makes the code generation quite simple as there is a direct translation of type rules to a function in the algorithm.
We will be generating Haskell code, since we can use the features in the Haskell language such as pattern matching and the use of monads to help produce relatively simple code from a given type specification.

\subsection{Example Languages}
\label{sec:exampleLanguages}
When discussing the features in JET, we will be discussing them in relation to two example languages.
These languages fulfil our aims for what language features we want JET to be able to type check given in \autoref{itms:aims}.
They also exhibit wildly different language features and paradigms so that we can demonstrate the diversity of languages that JET can type check.

The first of these languages is a language I have called Ad.
The language is a small imperative block structured language similar to Ada.
An Ad program is a series of type definitions followed by a procedure.
Procedures have a list of variable declarations as parameters.
Procedures consist of a list of declarations followed by a list of statements.
Declarations can introduce new variables or subprograms (collective term for a function or procedure).
A variable declaration consists of an identifier annotated with the type of the new variable, i.e. \texttt{x : Int}.
A function differs from a procedure in one way, a function returns a value whereas a procedure does not.
There are a number of built-in statements in the language, consisting of control flow statements; a statement to introduce a new block; an assignment statement; a procedure call statement and a print statement. 
The language also has a small number of built-in expressions: literal, arithmetic, Boolean, variable, and function call expressions.
Ad has two primitive types: integer and Boolean.
We are also able to express more complex types such as record and array types.
We can define type synonyms in Ad, type synonyms are similar to typedef's in C such that we can give a more complex type a name to reduce repeated type definitions in variable declarations.

Our second language is an implementation of the \textit{Simply Typed Lambda Calculus} (STLC).
STLC is a simple functional programming language.
A program in STLC consists of a single expression.
In the language we have access to simple arithmetic expressions; we then have more complicated expressions such as an if-expression and fix-expressions (this allows for recursive functions), we also have lambda abstraction (this creates an anonymous function that takes an expression as a parameter and has a single expression as a body), and function application that applies a given function with a given parameter.
The type system, while having the same primitive types as Ad, is quite different to the type system in Ad.
The major difference is that we have a function type which is a type that takes an input to an output, often represented as $\tau \rightarrow \sigma$ where $\tau$ is the type of the parameter and $\sigma$ is the type returned by the function.
This also means that the type system in STLC treats functions as "first-class citizens" as we can give functions as parameters to other functions and return new functions from a given function.
STLC is based off of the lambda calculus that is given in \textcite{pierce2002types}, they go into much more detail and have more extensions to STLC than we are going to consider here.

Full definitions of the abstract syntax and formal type systems for both of our example languages can be seen in \autoref{appendix:witnessLanguages}.
JET specifications for both of these languages are also provided.

\section{Overview of the JET Language}
The JET language has two main structural components: some Haskell code in an initial section\footnote{This is similar Flex and Bison's C code blocks to provide data structures and functions for the scanner and parser}, followed by a list of type rules.
The initial Haskell block is to allow the user to define functions and types that are to be used in the following type rules.

In order to write a type system in JET, the user will also have to provide a type which is an instance of a Haskell type class that defines a number of functions that will be useful when interacting with the context, such as looking up a variable in the context and adding an item to the context.
This type class has been written in such a way to support as many contexts as possible and not limit what kinds of languages JET can support.
Along with the type class, there is also be an example of how to implement an instance of the type class using a Haskell map as an example.

\subsection{Initial Inline Haskell}
The block of initial Haskell code, during code generation, will be placed just under the module definition but before the code for the type rules.
The inline Haskell code blocks take the form of $\{Code\}$, we chose a similar syntactic structure to code blocks in Flex and Bison (and their variants) so that the format will feel familiar to compiler writers.
As previously mentioned this is where a user can define functions and types required for the generated type checking code.
For example this is where a user can define the type for the context along with defining the instance of the type class \texttt{JetContext} for the users custom context type.
It also allows for the ability to import any other Haskell modules, this means that the user can import their Abstract Syntax Definition for that language that may be defined in a separate Haskell module.
An complete example for a block structured imperative language, similar to Add but with less features, can be seen in \autoref{lst:inlineHaskellCode}.
Here we define the context to be a 3-tuple which contains return type of the current subprogram, along with two namespaces, one for functions; and one for variables.
Namespaces, and their uses are discussed in detail \autoref{sec:context}.
These namespaces utilise the JetContextMap provided to the user.
JetContextMap is a list of Maps, where each Map is a scope in the code.
The instance of JetContext for JetContextMap is already defined for the user an example of how to define an instance of JetContext.

Having this inline code allows the user to specify exactly how they wish the context to function.
It also allows for a set of standard functions that the user can use to interact with the context, along with adding their own custom functions if and when they need them.

\subsection{Type Rule Format Overview}
\label{sec:typeRuleOverview}
The format of the type rules is extremely similar to the way we represent type rules in the natural deduction logic.
This allows for simple translation of a natural deduction type rule into one of the type rules written in JET.
We will delve into more detail about the format of the type rules, but the basic structure of the type rules is as follows

\begin{figure}[]
    \begin{grammar}
        <Rule> ::= `typerule' <Identifier> `<-' [ `if' <TypePremiseList> `then' ] <TypeConsequent> `return' <InlineHaskell>
    \end{grammar}
    \caption{BNF Grammar rule for defining a JET type rule}
    \label{fig:bnfTypeRuleBasic}
\end{figure}


The type premise list encased within the if-then is the list of judgments to prove the consequent.
It is possible for a type rule to require no judgments to prove the consequent so the if-then is optional, therefore, the type premise list can be forced to be nonempty.
The type premise after the if-then is the consequent we are trying to prove.
We then have a return keyword followed by some inline Haskell.
This is to allow the user to return any data that is required for type checking future AST Nodes.
For example, in our block structured language Ad, blocks are list of declarations followed by a list of statements.
When checking the declarations we will be adding new variables and subprograms to the context and when we finish checking the declarations we will want to return the context so that those variables and subprograms can be used in the statements.
If the context was not returned then those declared variables and subprograms would not be found in the context when they should have been.
The grammar of JET is designed to replicate as much as possible from the natural deduction rules as they are an already accepted way of formally representing type rules.
The formal grammar can be seen in its entirety in \autoref{appendix:jetLanguage}.

\section{Type Rules}
Type rules are how we express the type system for which we wish to generate the type checking code for.
Therefore, the structure and semantics of type rules will determine what language features JET can express and successfully generate valid code for the type checker.
We are going to be using the example languages seen in \autoref{sec:exampleLanguages} as motivation for the existence of features and their use.

\subsection{Basic Type Rules}
\label{sec:basisTypeRules}
\begin{figure}[]
    \centering
    \begin{subfigure}[b]{0.5\textwidth}
        \begin{prooftree}
            \LeftLabel{STLCIszero: }
            \AxiomC{$\Gamma \vdash e : Int$}
            \UnaryInfC{$\Gamma \vdash iszero\ e : Bool$}
        \end{prooftree}
        \caption{Type rule for iszero expression in STLC}
        \label{fig:iszeroTypeRule}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.4\textwidth}
        \begin{prooftree}
            \LeftLabel{STLCInt: }
            \AxiomC{}
            \UnaryInfC{$\Gamma \vdash n : Int$}
        \end{prooftree}
        \caption{Type rule for integer literal expression in STLC}
        \label{fig:intTypeRule}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.4\textwidth}
        \begin{prooftree}
            \LeftLabel{AdEqT: }
            \AxiomC{$\Gamma \vdash e_1 : \tau$}
            \AxiomC{$\Gamma \vdash e_2 : \tau$}
            \BinaryInfC{$\Gamma \vdash e_1 =  e_2 : Bool$}
        \end{prooftree}
        \caption{Type rule for equality expression in Ad}
        \label{fig:eqTypeRule}
    \end{subfigure}

    \caption{Examples of simple type rules}
    \label{fig:simpleTypeRulesExample}
\end{figure}

The type consequent is the most important part of the type rule, this is because the type consequent tells us exactly what part of the abstract syntax is being type checked along with the type associated with that piece of abstract syntax.
For example the type consequent for the type rule given in \autoref{fig:iszeroTypeRule} for STLC is:
\begin{lstlisting}[numbers=none]
(Expr Iszero e) : TBool
\end{lstlisting}
The consequent given represents exactly the same thing as the consequent in the natural deduction rule it simply just uses the abstract syntax that we have specified in \autoref{appendix:witnessLanguages}.
It is also worth to note that we associate the type consequent by writing a colon and the Haskell constructor or variable of the type we wish to associate with the consequent.
In this case it is the Haskell that identifies the Boolean type which is \texttt{TBool}.

Using the natural deduction rule in \autoref{fig:intTypeRule} we can create an example of our JET type rules and code that we generate from such an example.
The type rule is very simple, having no premises or side conditions, meaning that the type rule in our language should be just as simple:
\begin{lstlisting}[numbers=none]
typerule STLCInt <- (Literal LitInt n) : TInt 
    return {Succ ()};
\end{lstlisting}
There are three constituent parts to this type rule.
The first (\texttt{typerule STLCInt}) has no semantic meaning and is instead just an identifier for the type rule to be used for documentation purposes of the type system.
The second is the consequent of the type rule, taking a form similar to the previously discussed example, using the abstract syntax to pattern match on the literal expression for integer.
It is also annotated with the representation, in the abstract syntax, for integer in STLC.
The final part is the return statement.
This where any extra data, if necessary, is returned so that is can be used in the rest of the type checking, since this is just checking a literal integer there is no extra information that is useful from this type rule so we just return an empty tuple.
The type checking function we generate has to assert than the expected type is the same as the type associated with out type rule.
There are a number of way to do this in Haskell, the way in which we do it is within an if-expression in Haskell:
\begin{lstlisting}
checkLiteral (LitInt n) jetCheckType ctx = do
    if jetCheckType == TInt then Succ () 
    else Fail (makeCheckError (LitInt n) jetCheckType TInt)
\end{lstlisting}
The first thing you may notice is the name of the function, its suffix is the same as the first identifier in the consequent.
This is because the first identifier in the consequent must always be the type name of AST type we are type checking, in this case we are checking a \texttt{Literal}, in other cases we could be checking an \texttt{Expr} in which case we would replace that first identifier in the consequent.
This allows us to pattern match against any constructor of a given AST node. For example if we needed to type check against an arbitrary expression in our Ad language, that expression could be a literal expression or an addition expression or any other expression within the language.
If we were to have unique function for each possible kind of expressions, i.e. \texttt{checkEAdd}, then we could not match against any arbitrary expression, we would need to know the kind of expression before we can call a function.
However, if each expression is within the same function, then we can use Haskell's pattern matching features to identify what kind of expression it is and then execute the relevant type checking code for that kind of expression.
From this we can generalise the type consequent so that it has the format of \texttt{HaskellType HaskellTypeConstructor}.

The first parameter (\texttt{LitInt n}) of the function is the Haskell type constructor specified in the consequent, this allows for the required pattern matching so that we can call the correct type checking code.
The second parameter (\texttt{jetCheckType}) is the expected type to be associated with this type rule, this is the parameter that we will perform the equality check with when asserting whether or not the actual and the expected type match.
Finally, the last parameter it the current context which we are type checking in.
In this case the type rule does not interact with the context, however, more complicated type rules may interact with the context so it is required to be a parameter to every type checking function so that is never lost when performing the type checking.

Since this type rule has no premises the body of the function only has to check that the expected and actual type match.
If they do then we succeed and return whatever the inline Haskell was in the return statement of the type rule.
If not then we fail and generate some error message from a user defined error function.

We have discussed how to generate a type check function, however that is not the only function that is required. 
The infer function is used to return the type associated with a type rule so that the type can be used in other areas of the type checking.
For example, in the type rule show in \autoref{fig:eqTypeRule} we have two type premises both with type $\tau$, in this case $\tau$ is an arbitrary type but both instances of $\tau$ are the same.
Therefore we need a function that we can call so we can the type of piece of syntax, more commonly this is known as type inference\cite{cardelli1996type}.
Going back to our previous example (to see examples of type rules with premises go to \autoref{sec:premiseTypeRules}), we wish to generate code that will return the type associated with our type rule.
In this case we wish to return the type TInt, in this case we produce the following code:
\begin{lstlisting}[numbers=none]
inferLiteral (LitInt n) ctx = do Succ TInt
\end{lstlisting}
The function signature for our infer function is similar to the signature for our check function.
The difference is that we no longer require the \texttt{jetCheckType} parameter as we are no longer checking the type associate with our type rule matches some expected type, instead we are returning the type associated with our type rule.\todo{This sentence needs a rewrite}
Therefore, our function does not require the if-expression, instead we just wish to return the type \texttt{TInt}.

\subsection{Typeless Type Rules}
\label{sec:tltr}
\begin{figure}[]
    \begin{prooftree}
        \LeftLabel{AdNullT: }
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash \lfloor null \rfloor\ valid$}
    \end{prooftree}
    \caption{Type rule for a null statement in the Ad language}
    \label{fig:nullStmntTR}
\end{figure}

Some languages require that every type rule must have a type associated with it, STLC is an example of such a language; however, this is not the case for all languages.
For example, in our Ad language only expressions have types associated with them, every other syntactic part of the language is simply referred to as $valid$ if all of the premises of the type rule are true.
The simplest of these type rules is the null statement in the Ad language seen in \autoref{fig:nullStmntTR}, this is a simple type rule where if it is successfully parsed it will always be true as it has no premises.
This type rule given in JET is represented as:
\begin{lstlisting}[numbers=none]
typerule AdNullT <- (Stmnt SNull) return {Succ ()}
\end{lstlisting}

Here, unlike in previous type rules we have seen in \autoref{sec:basisTypeRules}, we have not specified the type associated with the type rules at all, it has been completely omitted.
This represents the concept of marking something as $valid$ in the natural deduction rules.
The code we generate is also substantially different (and much simpler) as we no longer need to check the type as there is no type, we also no longer need to generate an infer function to return a type as again there is no type to return:
\begin{lstlisting}[language=Haskell, numbers=none]
checkStmnt SNull ctx = do Succ ()
\end{lstlisting}
You may also notice that the parameter \texttt{jetCheckType} has also been omitted as there is no need for it since there is no type to check.

We could get the same functionality without this feature by having an internal type that represents $valid$.
In the Ad language we could \texttt{TNNone} for this purpose giving us the type rule:
\begin{lstlisting}[escapechar=\#, numbers=none]
typerule AdNullT <- (Stmnt SNull) #\textbf{: TNNone} return {Succ ()}
\end{lstlisting}
However, this is redundant as we are generating more code than necessary because we now have a type to check, where as before we did not.
This could potentially lead to a loss in performance since we are now having to perform an equality check and also have to give the \texttt{jetCheckType} parameter to the check function.
We will also generate an infer function since there is now the possibility to infer the type of such a statement where as in our original type rule we did not.

\subsection{Type Premises}
\label{sec:premiseTypeRules}

\begin{figure}[]
    \centering    
    \begin{subfigure}{0.6\textwidth}
        \begin{prooftree}
            \AxiomC{$\Gamma \vdash e_1 : Bool$}
            \AxiomC{$\Gamma \vdash e_2 : \tau$}
            \AxiomC{$\Gamma \vdash e_3 : \tau$}
            \TrinaryInfC{$\Gamma \vdash if\ e_1\ then\ e_2\ else\ e_3 : \tau$}
        \end{prooftree}
        \caption{Type rule for STLC if-expression}
        \label{fig:ifExprTypeRule}
    \end{subfigure}
    ~
    \begin{subfigure}{1\textwidth}
        \begin{prooftree}
            \AxiomC{}
            \RightLabel{Int}
            \UnaryInfC{$\Gamma \vdash 0 : Int$}
            \RightLabel{Iszero}
            \UnaryInfC{$\Gamma \vdash iszero\ 0 : Bool$}
            \AxiomC{}
            \RightLabel{Int}
            \UnaryInfC{$\Gamma \vdash 0 : Int$}
            \RightLabel{Pred}
            \UnaryInfC{$\Gamma \vdash pred\ 0 : Int$}
            \AxiomC{}
            \RightLabel{Int}
            \UnaryInfC{$\Gamma \vdash 0 : Int$}
            \RightLabel{Pred}
            \UnaryInfC{$\Gamma \vdash pred\ 0 : Int$}
            \RightLabel{Pred}
            \UnaryInfC{$\Gamma \vdash pred(pred\ 0) : Int$}
            \TrinaryInfC{$\Gamma \vdash if\ iszero\ 0\ then\ pred\ 0\ else\ pred\ (pred\ 0)$}
        \end{prooftree}
        \caption{Proof tree example for a STLC expression (Type rule names have been abbreviated)}
        \label{fig:proofTree}
    \end{subfigure}
    \caption{Type rule for if-expression and corresponding proof tree example}
\end{figure}

So far we have only discussed in detail type rules without premises.
However, for us to be able to type check and traverse the whole abstract syntax tree given to us by a parser we need to generate code that uses premises.
For example, if we use the natural deduction rule given in \autoref{fig:ifExprTypeRule}, the type rule we write in JET will need to represent the premises given in this type rule.
The code we generate will also want to call the code that checks all of the premises given for the type rule.
Considering the code snipped for STLC \texttt{if iszero 0 then pred 0 else pred (pred 0)} we get the proof tree seen in \autoref{fig:proofTree}.
We can see that the method of proving a sentence in a language is through recursive application of type rules until we reach a type rule that has no premises causing the proof to terminate, in this case the literal integer type rule acts as our base case for all of our premises.
The type rules we have already discussed are able to act as base cases to the recursive nature of type checking that we wish to generate code for.
Therefore, the code we wish to generate for type premises will need to replicate this recursive nature we desire.

Type premises have a similar syntax to type consequents.
More information that is required for a type premise, namely the context which the type premise is meant to be proved with respect to, for now we will be looking at type rules that do not interact with the context (go to \autoref{sec:context} to see type rules that interact with the context).
This gives means the general form of the type premise is:
\begin{grammar}
<TypePremise> ::= <InlineHaskell> `|-' `(' <Identifier> <Identifier> `)' [`:' <Type>]
\end{grammar}
Here, the first $Identifier$ is the type of the AST node for the premise; the second $Identifier$ is the variable that the premise is meant to check; $:\ Type$ is the optional type that is associated with the type premise.
We are now in a position to write a JET type rule for our type rule given in \autoref{fig:ifExprTypeRule}:
\begin{lstlisting}
typerule IfExpr <- if {ctx} |- (Expr e1) : TBool, 
        {ctx} |- (Expr e2) : t, 
        {ctx} |- (Expr e3) : t then 
    (Expr If e1 e2 e3) : t return {Succ ()}
\end{lstlisting}
We can see that a type premise list is a comma separated sequence of type premises.
This also the first time we have seen a JET type variable being used in a type rule.
There are a few sematic rules about type variables.
If we have said that the type of a premise is a type variable and this is the first occurrence of the type variable then we will be generating an infer function to get the value that the type variable is to represent.
Again, if we have said that the type of a premise is a type variable, but this time we have seen the type variable we will generate a check function where the type to check is the already defined type variable, this is to assert the two type variables are consistent.
Finally, if we use a type variable in the consequent then the variable should have been defined some where in the type premises.
From this set of rule we end up generating the following code:
\begin{lstlisting}
checkExpr (If e1 e2 e3) jetCheckType ctx = do
    var1 <- checkExpr e1 TBool ctx
    t <- inferExpr e2 ctx
    var2 <- checkExpr e3 ctx
    if jetCheckType == t then Succ () else Fail (makeCheckError (If e1 e2 e3) jetCheckType t)
inferExpr (If e1 e2 e3) jetCheckType ctx = do
    var1 <- checkExpr e1 TBool ctx
    t <- inferExpr e2 ctx
    var2 <- checkExpr e3 ctx
    Succ t
\end{lstlisting}
As can be seen, the final line of both functions are similar to the bodies of functions that we have seen that did not have type premises.
The other thing to notice, is that the code generated for the type premises appears in both of our generated functions, this is because in both instances we need to prove premises otherwise anything we state about the consequent could be incorrect.
Premises are evaluated in the order of left to right in the premise list, and the return value from check functions is stored in a variable with name $var_n$ where n is the next free natural number such that the variable name is unique.

\subsubsection{Type Variables as Parameters to Type Constructors}
\begin{figure}[]
    \begin{subfigure}{0.5\textwidth}
        \begin{prooftree}
            \LeftLabel{ArrAcc: }
            \AxiomC{$\Gamma \vdash e : Arr~\tau$}
            \AxiomC{$\Gamma \vdash n : Int$}
            \BinaryInfC{$\Gamma \vdash e[n] : \tau$}
        \end{prooftree}
    
        \caption{Type rule for array access in Ad}
        \label{fig:typeRuleArrAccess}
    \end{subfigure}
    ~
    \begin{subfigure}{0.4\textwidth}
        \begin{prooftree}
            \LeftLabel{Fix: }
            \AxiomC{$\Gamma \vdash e : \tau \rightarrow \tau$}
            \UnaryInfC{$\Gamma \vdash fix~e : \tau$}
        \end{prooftree}

        \caption{Type rule for fix point operator in STLC}
        \label{fig:typeRuleFix}
    \end{subfigure}

    \caption{Type rules with type variables as part of type constructors}
    \label{fig:complicatedTypeRules}
\end{figure}

We can also use type variables as parameters to the constructor of a full type definition.
Such examples of these types are array types in the Ad language, and a function type for STLC.
All elements in an array, in Ad, are all of the same type, therefore the type rule getting an element of the array will need to extract the type of the elements of the array.
In the natural deduction rules this is trivial, you represent arrays as $Arr~\tau$ where $\tau$ is the type of the elements of the array.
We can use a similar form of representing such types in JET.
For example, the type rule for array access in Ad is seen in \autoref{fig:typeRuleArrAccess}.
We can write the first type premise in JET in almost exactly the same way:
\begin{lstlisting}[numbers=none]
{ctx} |- (Expr e) : TArr t 
\end{lstlisting}
From this we can to generate some code of the form:
\begin{lstlisting}[numbers=none]
TArr t <- inferExpr e ctx
\end{lstlisting}
This code asserts that the type returned from the infer function must be an array type, we then get the parameter of the array type and store it in some variable t.
The generator will also have to add the variable t to the list of known type variables so that if another premise required the use of this type variable then we can generate a check function instead of an infer function.
There is one issue with the code that we generate at the moment.
If the return of the infer function does not match the pattern function then the type checker will error, but not with our defined error function since the error was an internal Haskell error.
Instead the right hand side of the binding will want to call our error function in case of a bad pattern match, from this criteria we produce the follow code:
\begin{lstlisting}[numbers=none]
TArr t <- case inferExpr e ctx of Succ jet0@(TArr t) -> Succ jet0; Succ t -> Fail (makeInferError t t); x -> x
\end{lstlisting}

\subsubsection{Side Conditions as Premises'}
\label{sec:scond}
There is another example of such a type rule, but instead this is part of STLC, can be seen in \autoref{fig:typeRuleFix}.
As can be seen there is the type $\tau \rightarrow \tau$ where both instances of $\tau$ are the same.
We would like to write the type premise as:
\begin{lstlisting}[numbers=none]
{ctx} |- (Expr e) : TFun t t
\end{lstlisting}
Where we assert that both instances of \texttt{t} are the same.
However the code we generate for this is not correct as we do not assert that both instances of \texttt{t} are the same, instead \texttt{t} is always the value of the second parameter to the type constructor.
Therefore, we write the type premise as:
\begin{lstlisting}[numbers=none]
{ctx} |- (Expr e) : TFun t1 t2
\end{lstlisting}
We also write a side condition premise such that asserts that \texttt{t1} and \texttt{t2} are the same and creates a new type variable \texttt{t} which is the same as \texttt{t1} and \texttt{t2}.
A side condition premise is piece of inline Haskell that is inserted into the generated code as a monadic statement, the used of the side conditions can be extremely varied in functionality and can do anything that the user requires that cannot be done as part of normal type premises.
One of the major uses of Haskell side conditions is for retrieving or expanding the context that we will see in \autoref{sec:context}.
Giving us the full type rule as follows:
\begin{lstlisting}
typerule Fix <- if {ctx} |- (Expr e) : TFun t1 t2, 
        {if t1 == t2 then Succ t1 else Fail "type error"} then 
    (Expr Fix e) : t1 return {Succ ()};
\end{lstlisting}

\section{List Notation Type Rules}
Many languages, in their abstract syntax, have nodes that take a list of nodes to be one of their children, an example of this can be seen as a sequence of statements that make up the body of a procedure or function as part of the Ad language in \autoref{appendix:witnessLanguages}.
In the set of features discussed there is no simple way to represent type rules that act on these kinds of nodes.

\subsection{List Notation in Type Premises}
Using list notation in type premises is similar to how normal type premises are used.
The one difference is instead of encasing the premise with parentheses, we instead encase it within square brackets.
This so that it matches how lists are defined in Haskell, therefore, the users should be familiar with square brackets being associated with lists.
The example for the list of statements is given as \texttt{\{ctx\} |- [Stmnt stmnts]}.
As can be seen it is exactly the same is a normal type premise, with only the type of brackets used being different so that both the user and the tool can tell the difference.
The code that is produced from this type of premise is also very similar to the code produced from a normal premise: \texttt{var1 <- checkStmntList stmnts ctx}.
How the parameters are passed, along with how the result of the premise is bound to a variable, is exactly the same.
The only difference being is the function name has \texttt{List} as a suffix.
If we did not have this suffix then we would call \texttt{checkStmnt} which would lead to a type error as \texttt{checkStmnt} has the type: \texttt{Stmnt -> Context -> JetError a}, whereas the function we are trying to call would have to have type: \texttt{[Stmnt] -> Context -> JetError a}.
The difference being, one expects a statement, the other expects a list of statements.

\subsection{List Notation Type Rules}
We have discusses how list notation is used in premises, however, that is not useful unless code can be generated for type rules using list notation.
Type rules for list notation bear a resemblance to normal type rules.
They have different semantics for the consequent but the type premises have the same semantics we have previously discussed.
Similarly to premises, instead of being encased in parentheses they are encased in square brackets.
The major differences occur in the variables that are defined within the rule and what semantic meaning they have.
The simplest form is to just define the Node type and nothing else, for example: \texttt{[Stmnt]}.
This will pattern match on the empty list, in this case, when all statements have been successfully type checked.
The next pattern has the Node type and a variable name, given as: \texttt{[Stmnt s]}.
The pattern matched on the singleton list, where the element with in the list is given the variable name given in the type rule.
The final pattern that exists is the list constructor pattern, this, similar the the last two,  is given as the Node type but now followed by two variable names.
The first variable represents the head of the list to be type checked (the first item), the second variable represents the tail of the list to be type checked (The rest of the list after the head has been removed).
The variables in these type rules can be used the in the premises the same as any other variables.

\begin{figure}
    \begin{prooftree}
        \LeftLabel{StmntList: }
        \AxiomC{$\Gamma \vdash \lfloor stmnt \rfloor\ valid $}
        \AxiomC{$\Gamma \vdash \lfloor stmnts \rfloor \ valid$}
        \BinaryInfC{$\Gamma \vdash \lfloor stmnt;\ stmnts \rfloor\ valid$}
    \end{prooftree}
    \caption{Type rule for a sequence of statements in the Ad language}
    \label{fig:StmntListTypeRule}
\end{figure}

An example of how to define a type rule in list notation is when type checking a list of statements.
The type rule in natural deduction logic can be seen in \autoref{fig:StmntListTypeRule}.
The premises in this type rule make a recursive type rule, and our the type rule in JET will have to reflect this meaning.
In the scenario given, the list statements must non-empty, we can create type rules that assert that the non-empty property must hold.

\begin{lstlisting}[caption = Type rule in JET for a seqeunce of statements, label=lst:jetStmntList]
typerule StmntListCons <- if {ctx} |- (Stmnt stmnt), 
        {ctx} |- [Stmnt stmnts] then 
    [Stmnt stmnt stmnts] return {Succ ()};
typerule StmntListSngltn <- if {ctx} |- (Stmnt stmnt),
    then [Stmnt stmnt] return {Succ ()};
\end{lstlisting}

We therefore have the the type rule in JET that can be seen in \autoref{lst:jetStmntList}.
As can be seen to create the behavior we desire need two type rules, one for when we have a list arbitrary length, and another for when the list contains a single item.
This structure forces the list to be nonempty and the type checker will error if the list happens to be empty.
Another important aspect to note is that we can recursively call out same type rule in order to type check the while list.
This can be seen in the list constructor type rule where we type check the current statement but then also go on to type check the rest of the list.
These patterns should be able to handle any usual type rule that a user is going to write.
However they do not cover every possible pattern that could occur as they do not replicate how Haskell does pattern matching on lists but instead uses a subset of the patterns that Haskell has available.
It could be possible in future to expand these patterns so that they do match all of the patterns that Haskell can handle, however we did not require this feature to type check the witness languages given.

\section{Interacting with the Context}
\label{sec:context}
Using side conditions to update and lookup items within the context is very common when specifying the natural deduction rules.
We have discussed in \autoref{sec:scond} how side conditions work in JET and how the code is generated for them.
To make interacting with the context through Haskell side conditions easier and more consistent, there is a Haskell type class that has been provided to the user to give them a common interface to interact with the context\footnote{The definition of this type class (called \texttt{JetContext}) is provided in ref to haskell modules!!!!!!!!}.
It is important to note that these modules do not define the context for the user, the user will have to define their own context type and instantiate the Haskell type class for their own context type.
This is because many different languages can have contexts that work differently and letting the user define their own context gives them greater control on the semantics of the context.
There is an example provided to the user of how to do this using Haskell Data Maps\todo{cite data maps} so that the user is not on their own in this regard, the name of the type for this example is \texttt{JetContextMap}.
The semantics of the each function will be explained using the provided example.

\subsection{Empty Contexts and Blocks}
\label{sec:blocks}
\begin{lstlisting}[language=ada, caption=Example of declarations in a block structured language such as Ad, label=lst:blockDecl]
declare
    x : int; -- This will succeed
begin
    declare
        x : bool; -- This will also succeed because the variable is re-declared in a new block
        x : int; -- This will fail because the variable was re-declared in the same block as the previous declaration
    begin
    end;
end;
\end{lstlisting}

The basic thing you can do with a context is create an empty context or add a new block to the context.
An empty context should do exactly what the name suggests, it should be a new context that has no items in it.
Since the user implements all the functions they should ensure that their function meets these semantic requirements.
There is an assumption that all languages will have a block structure even if that block structure is trivial, and if a language is not a block structured language it can be modelled by having a context which will only ever have one block.
How the context represents blocks is up to the user, however in our \texttt{JetContextMap} example a single block is a map and our context is made up of a list of blocks.
The reason for this is simple, consider the Ad program given in \autoref{lst:blockDecl}.
We want to be able to re-declare variables as long as the variable to re-declare does not exist in the current block.
If the context was just a single map then there would be no way of knowing whether or not a variable was declared in the current block, we would only be able to know if a variable was declared in any block.
This gives us the formal definition of the context to be a sequence of functions which maps names to types given as $\langle Name \rightarrow Type \rangle$

\begin{figure}[]
    \centering
    \begin{prooftree}
        \AxiomC{$\langle \emptyset \rangle ^\frown \Gamma \vdash \lfloor decls \rfloor valid$}
        \AxiomC{$\langle \{decls\} \rangle ^\frown \Gamma \vdash \lfloor stmnts \rfloor~valid$}
        \BinaryInfC{$\Gamma \vdash \lfloor$ declare $decls$ begin $stmnts$ end $\rfloor~valid$}
    \end{prooftree}
    \caption{Type rule for a new block in the Ad language}
    \label{fig:typeRuleBlock}
\end{figure}

These functions can be used anywhere inline Haskell can be used.
However, they will most likely be used in the context definition for type premise's.
An example of natural deduction rule defining a new block for the Ad language can be seen in \autoref{fig:typeRuleBlock}.
Our first premise states, given a sequence containing an empty set (conceptual a mapping of names to types containing nothing), concatenated with our current context check our declarations.
The second premise states check the statements of the block given a new block containing all of our declarations concatenated with the current context.
The following type rule in JET represents this natural deduction rule:
\begin{lstlisting}
typerule BlockT <- if {(newBlock ctx)} |- [Decl decls],
        {var1} |- [Stmnt stmnts] then
    (Stmnt SBlock decls stmnts) return {Succ ()};
\end{lstlisting}
We use \texttt{var1} for the context to the second premise because \texttt{var1} is the context returned from the first premise which has all of the declarations added to the context.
This is required so that those declarations are visible to the statements in the block.

\subsection{Lookup, Expand}
\begin{figure}[]
    \centering
    \begin{subfigure}{1\textwidth}
        \begin{prooftree}
            \LeftLabel{VarT: }
            \RightLabel{$[\tau = lookup(v, \Gamma)]$}
            \AxiomC{}
            \UnaryInfC{$\Gamma \vdash v : \tau$}
        \end{prooftree}
        \caption{Type rule for using a variable in the Simply Typed Lambda Calculus and Ad languages}
        \label{fig:varTypeRule}
    \end{subfigure}
    ~
    \begin{subfigure}{1\textwidth}
        \begin{prooftree}
            \LeftLabel{AdVarDecl: }
            \AxiomC{$(head (\Gamma) \oplus {v : \tau}) ^\frown (tail (\Gamma)) \vdash \lfloor decl \rfloor$}
            \RightLabel{$[v \notin dom((head(\Gamma)))]$}
            \UnaryInfC{$\Gamma \vdash \lfloor v : \tau; decls \rfloor\ valid$}
        \end{prooftree}
        \caption{Type rule for variable declaration in the Ad language}
        \label{fig:varDeclTypeRule}
    \end{subfigure}
    ~
    \begin{subfigure}{1\textwidth}
        \begin{prooftree}
            \LeftLabel{AdVarDecl: }
            \AxiomC{$expandContext(v,\tau,\Gamma) \vdash \lfloor decls \rfloor$}
            \UnaryInfC{$\Gamma \vdash \lfloor v : \tau; decls \rfloor\ valid$}
        \end{prooftree}
        \caption{Type rule for variable declaration in the Ad language using functions from the Haskell type class}
        \label{fig:modvarDeclTypeRule}
    \end{subfigure}
    \caption{}
    \label{}
\end{figure}

The most common use of the context is when attempting to retrieve types of objects from the context.
We will want to do two main actions with variables, the first is to retrieve the type of a variable from the context, the second is to add a new variable with a given type to the context.
Retrieving the type of a variable from the context is given by the natural deduction rule in \autoref{fig:varTypeRule}.
The consequent is trivial and is the same as the ones we have seen throughout \autoref{sec:basisTypeRules}.
We still need to retrieve the arbitrary type $\tau$ from the context.
this can be done by using the function, given by the \texttt{JetContext} type class, \texttt{lookupContext}.
This function, given some a parameter to identify the item in the context (such as the variable name), will return the type associated with the input, or will return some fail message within the \texttt{JetError} monad.
When using this in a Haskell side condition we will want to bind the resulting type from the context to the variable that we are going to use as the type for the consequent.
If we say that the return variable of the consequent is \texttt{t}, then we will want to write the side condition as \texttt{\{t <- lookupContext var ctx\}}, where \texttt{var} is the variable to lookup and \texttt{ctx} is the given context to perform the lookup in.
We do not do anything special when generating the code from a Haskell side condition, we simply put it directly into the generated code in the position it occurs in the premise list (In this example it is the only premise so that does not matter just as long as it appears before the return monadic statement).

We can now retrieve types from the context, however, that is not useful unless we can add objects to the context.
We will be using the example that can be seen in \autoref{fig:varDeclTypeRule} taken from the Ad language.
The type rule has a very complicated predicates for the new context and also for the side condition for the type rule.
However, the functionality can be encoded into the \texttt{expandContext} function.
The \texttt{expandContext}, takes as parameters the object, the type to associate with the object, and the context to add the object to.
The function will return an error monad, therefore if the function is successful it will return the new context otherwise it will return an error.
If we were to then use this function to write the natural deduction rule again we would get the rule given in \autoref{fig:modvarDeclTypeRule}.

The new version of the natural deduction rule is now much easier to write in JET because we can use the function from our type class.
We write the type rule in JET as the following:
\begin{lstlisting}[numbers=none]
typerule VDeclT <- (VarDecl VDecl var t) return {expandContext var t ctx};
\end{lstlisting}
There is no need for the premise in our JET type rules as we write that using the list notations, this type rule is simply to add the variable to the context therefore we need to return the new context which has been expanded with the variable rather than returning the Unit type that we have seen in every other type rule so far.
The code we produce for this is similar to the typeless type rules seen in \autoref{sec:tltr} but with the expand function in place of \texttt{Succ ()}:
\begin{lstlisting}[numbers=none]
checkVarDecl (VDecl var t) ctx = do
    expandContext var t ctx
\end{lstlisting}

\subsection{Name-spaces}
\begin{figure}[]
    \centering
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash params : \tau_{es}$}
        \RightLabel{$[\tau = lookup((f, \tau_{params}),F)]$}
        \UnaryInfC{$\Gamma \vdash f(params) : \tau$}
    \end{prooftree}
    \caption{Type rule for function call in Ad}
    \label{fig:typeRuleFunc}
\end{figure}

Name-spaces are not directly supported in the JET language, as they are in typical\cite{grimm2007typical}.
They are a common construct in programming languages and a useful way of splitting the context into multiple parts.
This means that in JET, we can have variable, a function, a procedure and type all have the same name but we can figure out which one we mean based upon when it is being used.
For example, in the Ad language we will want to have multiple name-spaces, one for variables, one for functions and one for procedures and a final one for type definitions.
Where as in the STLC we only have one name-space for variables.
For our Ad language we need to construct our context in such a way that we can have all of the name-spaces we require.
We do this using a 4-tuple where the items for variables, functions and procedures are the block structures we discussed in \autoref{sec:blocks}, where as our structure for type definitions is just a map because types can only be defined at the start of the program.
The formal definition for the current context we require for Ad is $(V, P, F, T)$ where $V$ is the variables, $P$ is the procedures, $F$ is the functions and $T$ are the type definitions, however $\Gamma$ will still be used to denote the whole context.
Therefore is we are trying to type check a function call we will get the natural deduction rule given in \autoref{fig:typeRuleFunc}.
If we are using the context definition for Ad, in \autoref{appendix:witnessLanguages}, then we would be able to write this type rule in JET, using list notation to get the types of the parameters, as:
\begin{lstlisting}
typerule FCallT <- if {ctx} |- [Expr params] : tparams, 
        {t <- lookupContext (Func ident tparams) ctx} then 
    (Expr ECall ident params) : t return {Succ ()};
\end{lstlisting}
The Haskell side condition used here is very similar to the one that was shown previously when descibing how the function \texttt{lookupContext} works and how it is meant to be used.
This time however, the first parameter has a different form.
In this case it has the form of the name-space which we want to look for the object in followed by the object that we wish to fine, in this example the object is the identifier of the function and the types of the parameters to the function.
Therefore, \texttt{ident tparams} is analogous to $(f, \tau_{params})$ in the natural deduction rule, and we give the whole context to the function and we let the function decide what name-space to look in based upon the pattern of the first argument, i.e. what constructor is used for the first argument, in this case it is the \texttt{Func}, from the type:
\begin{lstlisting}[numbers=none]
data ContextKey = Ret | Proc Ident [Type] | Func Ident [Type] | Var Ident | Typ Ident
    deriving (Eq, Ord, Show, Read)
\end{lstlisting}
This type is what is used as the "key" type for the \texttt{JetContext} instance for the custom type used for the context for the Ad language.
The type here has one more item in the tuple that we didn't initially give in our formal definition of the Ad context and that is the constructor \texttt{Ret}.
That item is used to denote the current return type of the current subprogram we are in.
This means the new formal definition for the context for the Ad language is a 5-tuple given as $(\tau_{ret}, V, P, F, T)$ where the variables that existed previously mean the same and $\tau_{ret}$ denotes the current return type.
This piece of information is required so that return statement can be correct type checked when it is used.
For example, if the return statement is used in a procedure that should result in a type error as a procedure does not return a value and the way we know that we are in a procedure, in Ad, is the return type in will be $none$.
This can be used by the \texttt{lookupContext} and \texttt{expandContext} functions just like the other constructors for that type, the only difference is the constructor does not require any parameters.
