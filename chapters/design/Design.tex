\chapter{Design and Implementation of Notation}
\label{chap:Method}
Before we can generate type checking code we need to have a way of specifying the type system such that a program can read the given specification and generate the required code.
The way we will be specifying the the type system is through a domain specified language I have designed called \textit{JET Expresses Types} (JET).
The way type rules are written in JET are analogous to the natural deduction rules to define the type system.
This made the most sense as other parts of the compiler pipeline already have domain specific languages that are used to generate code.

In JET, rather than using the concrete syntax that is used in the natural deduction rules, we use the abstract syntax provided by the user to define the type rules.
We are using the abstract syntax for a number of reasons; the first reason is that we are going to be type checking input that has already been parsed therefore we are going to be type checking the abstract syntax tree and not the input of the concrete syntax.
The second reason, it is possible to type check an intermediate representation of a language.
Intermediate representations may only be represented through abstract syntax and have no concrete syntax, for example, Haskell's intermediate representation (known as core) is type checked during Haskell's compilation process\cite{marlow2004glasgow}.
Type rules in JET have a similar form to the natural deduction rules, such that there is a rule name followed by some judgments and then the consequent.
This provides a common way of representing type rules even if the way of writing the rules in JET uses an ASCII representation of the natural deduction rules.

The code we are generating is based off of the type checking and type inference algorithm described in \textcite{ranta2012implementing}.
This is because the algorithms described are simple, yet powerful enough to express common type rules, such as arithmetic expressions and also allow for the use of functions and variables.
It also makes the code generation quite simple as there is a direct translation of type rules to a function in the algorithm.
We will be generating Haskell code, since we can use the features in the Haskell language such as pattern matching and the use of monads to help produce relatively simple code from a given type specification.

\subsection{Example Languages}
\label{sec:exampleLanguages}
When discussing the features in JET, we will be discussing them in relation to two example languages.
These languages fulfil our aims for what language features we want JET to be able to type check given in ??\todo{ref aims}.
They also exhibit wildly different language features and paradigms so that we can demonstrate the diversity of languages that JET can type check.

The first of these languages is a language I have called Ad.
The language is a small imperative block structured language similar to Ada.
An Ad program is a series of type definitions followed by a procedure.
Procedures have a list of variable declarations as parameters.
Procedures consist of a list of declarations followed by a list of statements.
Declarations can introduce new variables or subprograms (collective term for a function or procedure).
A variable declaration consists of an identifier annotated with the type of the new variable, i.e. \texttt{x : Int}.
A function differs from a procedure in one way, a function returns a value whereas a procedure does not.
There are a number of built-in statements in the language, consisting of control flow statements; a statement to introduce a new block; an assignment statement; a procedure call statement and a print statement. 
The language also has a small number of built-in expressions: literal, arithmetic, Boolean, variable, and function call expressions.
Ad has two primitive types: integer and Boolean.
We are also able to express more complex types such as record and array types.
We can define type synonyms in Ad, type synonyms are similar to typedef's in C such that we can give a more complex type a name to reduce repeated type definitions in variable declarations.

Our second language is an implementation of the \textit{Simply Typed Lambda Calculus} (STLC).
STLC is a simple functional programming language.
A program in STLC consists of a single expression.
In the language we have access to simple arithmetic expressions; we then have more complicated expressions such as an if-expression and fix-expressions (this allows for recursive functions), we also have lambda abstraction (this creates an anonymous function that takes an expression as a parameter and has a single expression as a body), and function application that applies a given function with a given parameter.
The type system, while having the same primitive types as Ad, is quite different to the type system in Ad.
The major difference is that we have a function type which is a type that takes an input to an output, often represented as $\tau \rightarrow \sigma$ where $\tau$ is the type of the parameter and $\sigma$ is the type returned by the function.
This also means that the type system in STLC treats functions as "first-class citizens" as we can give functions as parameters to other functions and return new functions from a given function.
STLC is based off of the lambda calculus that is given in \textcite{pierce2002types}, they go into much more detail and have more extensions to STLC than we are going to consider here.

Full definitions of the abstract syntax and formal type systems for both of our example languages can be seen in \autoref{appendix:witnessLanguages}.
JET specifications for both of these languages are also provided.

\section{Overview of the JET Language}
The JET language has two main structural components: some Haskell code in an initial section\footnote{This is similar Flex and Bison's C code blocks to provide data structures and functions for the scanner and parser}, followed by a list of type rules.
The initial Haskell block is to allow the user to define functions and types that are to be used in the following type rules.

In order to write a type system in JET, the user will also have to provide a type which is an instance of a Haskell type class that defines a number of functions that will be useful when interacting with the context, such as looking up a variable in the context and adding an item to the context.
This type class has been written in such a way to support as many contexts as possible and not limit what kinds of languages JET can support.
Along with the type class, there is also be an example of how to implement an instance of the type class using a Haskell map as an example.

\subsection{Initial Inline Haskell}
The block of initial Haskell code, during code generation, will be placed just under the module definition but before the code for the type rules.
The inline Haskell code blocks take the form of $\{Code\}$, we chose a similar syntactic structure to code blocks in Flex and Bison (and their variants) so that the format will feel familiar to compiler writers.
As previously mentioned this is where a user can define functions and types required for the generated type checking code.
For example this is where a user can define the type for the context along with defining the instance of the type class \texttt{JetContext} for the users custom context type.
It also allows for the ability to import any other Haskell modules, this means that the user can import their Abstract Syntax Definition for that language that may be defined in a separate Haskell module.
An complete example for a block structured imperative language, similar to Add but with less features, can be seen in \autoref{lst:inlineHaskellCode}.
Here we define the context to be a 3-tuple which contains return type of the current subprogram, along with two namespaces, one for functions; and one for variables.
Namespaces, and their uses are discussed in detail ??\todo{ref context sections}.
These namespaces utilise the JetContextMap provided to the user.
JetContextMap is a list of Maps, where each Map is a scope in the code.
The instance of JetContext for JetContextMap is already defined for the user an example of how to define an instance of JetContext.


\begin{minipage}{\linewidth}
\begin{lstlisting}[caption = Example of initial inline haskell code, label=lst:inlineHaskellCode, language=Haskell]
{
import qualified Data.Map as M
import AbsAd

data ContextKey = Ret | Func Ident [Type] | Var Ident
    deriving (Eq, Ord, Show, Read)

newtype Context = Context (Type, JetContextMap (Ident, [Type]) Type, JetContextMap Ident Type)
    deriving (Eq, Ord, Show, Read)

instance JetContextBase Context where
    emptyContext = Context (TNNone, emptyContext, emptyContext)
    newBlock (Context (t, f, v) = Context (t, newBlock f, newBlock v)

instance JetContext Context ContextKey Type where
    lookupContext Ret (Context (r, _, _, _, _)) = return r
    lookupContext (Func ident ts) (Context (_, _, f, _, _)) = lookupContext (ident, ts) f
    lookupContext (Var ident) (Context (_, _, _, v, _)) = lookupContext ident v
    expandContext Ret t (Context (_, p, f, v, s)) = return (Context (t, p, f, v, s))
    expandContext (Func ident ts) t (Context (rt, p, f, v, s)) = do
        f' <- expandContextIf (\(i, t) (JetContextMap (b:bs)) -> null (filter (\(i', t') -> i == i') (M.keys b))) (ident, ts) t f
        return (Context (rt, p, f', v, s))
    expandContext (Var ident) t (Context (rt, p, f, v, s)) = do
        v' <- expandContext ident t v
        return (Context (rt, p, f, v', s))

makeCheckError e t1 t2 = "Type error"
makeCheckErrorList _ _ _ = "Type error"
makeInferError _ _ = "Type error"
}
\end{lstlisting}
\end{minipage}

Having this inline code allows the user to specify exactly how they wish the context to function.
It also allows for a set of standard functions that the user can use to interact with the context, along with adding their own custom functions if and when they need them.

\subsection{Type Rule Format Overview}
The format of the type rules is extremely similar to the way we represent type rules in the natural deduction logic.
This allows for simple translation of a natural deduction type rule into one of the type rules written in JET.
We will delve into more detail about the format of the type rules, but the basic structure of the type rules is as follows

\begin{figure}[]
    \begin{grammar}
        <Rule> ::= `typerule' <Identifier> `<-' [ `if' <TypePremiseList> `then' ] <TypeConsequent> `return' <InlineHaskell>
    \end{grammar}
    \caption{BNF Grammar rule for defining a JET type rule}
    \label{fig:bnfTypeRuleBasic}
\end{figure}


The type premise list encased within the if-then is the list of judgments to prove the consequent.
It is possible for a type rule to require no judgments to prove the consequent so the if-then is optional, therefore, the type premise list can be forced to be nonempty.
The type premise after the if-then is the consequent we are trying to prove.
We then have a return keyword followed by some inline Haskell.
This is to allow the user to return any data that is required for type checking future AST Nodes.
For example, in our block structured language Ad, blocks are list of declarations followed by a list of statements.
When checking the declarations we will be adding new variables and subprograms to the context and when we finish checking the declarations we will want to return the context so that those variables and subprograms can be used in the statements.
If the context was not returned then those declared variables and subprograms would not be found in the context when they should have been.
The grammar of JET is designed to replicate as much as possible from the natural deduction rules as they are an already accepted way of formally representing type rules.
The formal grammar can be seen in its entirety in \autoref{appendix:jetLanguage}.

\section{Type Rules}
Type rules are how we express the type system for which we wish to generate the type checking code for.
Therefore, the structure and semantics of type rules will determine what language features JET can express and successfully generate valid code for the type checker.
We are going to be using the example languages seen in \autoref{sec:exampleLanguages} as motivation for the existence of features and their use.

\begin{figure}[]
    \begin{grammar}
        <TypeConsequent> ::=  <TypeJudgement>
        
    
        <IdentifierList> ::= $\epsilon$ | <Identifier> <IdentifierList>
    
        <TypePremiseList> ::= <TypePremise> 
            \alt <TypePremise> <TypePremiseList>
    
        <TypePremise> ::= <InlineHaskell>
            \alt <InlineHaskell> `|-'  <TypeJudgement>
    
        <TypeJudgement> ::= `(' <Identifier> <Identifier> <IdentifierList> `)' <Type>
        
        <Type> ::= $\epsilon$ | `:' <Identifier> <IdentifierList>
    \end{grammar}
    \caption{BNF Grammar rule for constituent parts of a JET type rule}
    \label{fig:bnfTypeRuleComp}
\end{figure}

We have already seen a brief overview of the structure of type rules; now we will go into more detail about the structure and what sematic meaning different syntactic parts of the type rule have.
The grammar rule seen in \autoref{fig:bnfTypeRuleComp}, along with the one in \autoref{fig:bnfTypeRuleBasic} gives us the whole of our basic JET grammar.

\subsection{Associating Types with Type Rules}


\subsection{Typeless Type Rules}
\begin{figure}[]
    \begin{prooftree}
        \LeftLabel{AdNullT: }
        \AxiomC{}
        \UnaryInfC{$\Gamma \vdash \lfloor null \rfloor\ valid$}
    \end{prooftree}
    \caption{Type rule for a null statement in the Ad language}
    \label{fig:nullStmntTR}
\end{figure}

Some languages require that every type rule must have a type associated with it, STLC is an example of such a language; however, this is not the case for all languages.
For example, in our Ad language only expressions have types associated with them, every other syntactic part of the language is simply referred to as $valid$ if all of the premises of the type rule are true.
The simplest of one of these type rules is the null statement in the Ad language seen in \autoref{fig:nullStmntTR}, this is a simple type rule where if it is successfully parsed it will always be true as it has no premises.
This type rule given in JET is represented as:\\
\begin{lstlisting}[numbers=none]
typerule AdNullT <- (Stmnt SNull) return {Succ ()}
\end{lstlisting}

Here, unlike in previous type rules we have seen, we have not specified the type associated with the type rules at all, it has been completely omitted.
This represents the concept as marking something as $valid$ in the natural deduction rules.
The code we generate is also substantially different (and much simpler) as we no longer need to check the type as there is no type, we also no longer need to generate an infer function to return a type as again there is no type to return:\\
\begin{lstlisting}[language=Haskell, numbers=none]
checkStmnt SNull ctx = Succ ()
\end{lstlisting}
You may also notice that the parameter \texttt{jetCheckType} has also been omitted as there is no need for it since there is no type to check.

We could get the same functionality without this feature by having an internal type that represents $valid$.
In the Ad language we could \texttt{TNNone} for this purpose giving us the type rule:\\
\begin{lstlisting}[escapechar=\#, numbers=none]
typerule AdNullT <- (Stmnt SNull) #\textbf{: TNNone} return {Succ ()}
\end{lstlisting}
However this is redundant as we are generating more code than necessary as we now have a type to check, where as before we did not.
This could potentially lead to a loss in performance (albeit a small one) since we are now having to perform an equality check and also have to give the \texttt{jetCheckType} parameter to the check function.
We will also generate an infer function since there is now the possibility to infer the type of such a statement where as in our original type rule we did not.

\subsection{Type Premises}
Type rules without premises are some of the most simple type rules as they require nothing other than the consequent to be defined.


\section{Interacting Context}

\section{List Notation Type Rules}

%\input{chapters/design/Language.tex}
%\input{chapters/design/SimpleTypeRules.tex}
%\input{chapters/design/TypePremises.tex}
%\input{chapters/design/ListNotation.tex}
%\input{chapters/design/Context.tex}