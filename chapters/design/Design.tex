\chapter{Method}
\label{chap:Method}
Before we can generate type checking code we need to have a way of specifying the type system in such that a program can read the given specification and generate the required code.
The way we will be specifying the the type system is through a domain specified language I have designed called JET Expresses Types (JET).
The way type rules are written in JET are analogous to the natural deduction rules to define the type system.
This appeared to make the most sense as other parts of the compiler pipeline already have domain specific languages that are used to generate code.

In JET, rather than using the concrete syntax that is used in in the natural deduction rules, uses the abstract syntax provided by the user, to define the type rules.
Type rules in JET have a have a similar form to the natural deduction rules, such that there is a rule name followed by some judgments and then the consequent.
This provides a common way of representing type rules even if the way of writing the rules in JET use an ascii representation of the natural deduction logic.

The code we are generating is based off of the type checking and type inference algorithm described in Implementing Programming Languages\cite{ranta2012implementing}.
This is because the the algorithms described are simple yet powerful enough to express common type rules, such as arithmetic expressions and also allow for the use of functions and variables.
It also makes the code generation quite simple as there is a, more or less, direct translation of type rules to a function in the algorithm.

The code we will be generating will be Haskell code, since we can use the features in the Haskell language such as pattern matching and the use of monads to help produce relatively simple code from a given type specification.

Below is explained how the language is used, why certain design decisions were made and what code is generated from the input source. 
This will be demonstrated using a small number of  witness languages defined in \autoref{appendix:witnessLanguages}.
The first language is a simple imperative language. 
The language consists of single procedure in which you can define more procedures and subprograms along with define variables. In the body of the procedure is a series of statements such as a block statement, if-else statement, and for subprograms a return statement. The language is similar to Ada but much simpler.
The next language is the simply typed lambda calculus, this will allow the demonstration of type checking higher order functions; lambda abstraction; and let expressions.
The lambda calculus is based off of the definition that can be found in Pierce's book, Types and Programming Languages\cite{pierce2002types}.

\input{chapters/design/Language.tex}
\input{chapters/design/SimpleTypeRules.tex}
\input{chapters/design/TypePremises.tex}
\input{chapters/design/ListNotation.tex}
\input{chapters/design/Context.tex}