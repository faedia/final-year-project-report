\chapter{Introduction}
\label{chap:intro}
Programming languages have had type systems and type checkers dating back to Fortran\cite{Backus:1978:HFI:960118.808380}.
Since then, type systems have gone through many changes and an academic body of research has developed out of type systems to explore what information they can represent\cite{cardelli1996type}.
Over the past few decades type systems for modern programming languages have grown in sophistication and as a consequence type checkers have grown more complicated.
As software becomes more complex, the likelihood for errors occurring becomes higher.
If there is an error in a type checker then there is the possibility of code containing errors being passed through the compiler successfully, whereas if the compiler were to behave correctly, such an error could have been caught.

This leads to the possibility of generating the code for the type checkers based upon the specification of the type systems in order to remove some of the complexity of developing the type checker.
Therefore, a notation will be presented that can be used to represent a specification of a type system
From this notation code can be generated that implements the specification it is representing.
The notation should be simple to use and easy to understand, The simplicity of such a notation should reduce the number of errors that occur in these complicated pieces of software.
It should also be able to generate code for a large variety of programming languages with many different language features.
The following list is the list of required features that our notation should have or be able to represent:
\begin{itemize}
    \label{itms:aims}
    \item Simple notation similar to the current method of representing type systems in academic literature but that should also be easy to understand by people not familiar with the academia.
    \item Be able to generate code for many different languages, for example for imperative and function programming languages.
    \item Be able to generate code for simple arithmetic expressions and simple statements, i.e. an addition expression and loop statements.
    \item Be able to generate code for variables and subprograms (functions and procedures).
    \item Be able to represent more complex data types, ranging from array types and record types, to functions types (i.e. lambda expressions).
\end{itemize}

These required features should allow for the notation to represent many kinds of type systems.
They should also allow for the notation, and corresponding generated code, to be sophisticated enough to type check most simple languages whilst also allow for the possibility for extensions to add more supported kinds of languages in the future.
This list of required features is how we will check for the success of the project and the notation.
However, there is another set of features that are desirable but not required features.
For example, all things permitting, it should be able to generate code for and represent user defined types types and type synonyms (i.e. typedef's in C\cite{kernighan2006c}).
Another possible feature is to generate code for Hindley-Milner type inference\cite{MILNER1978348}, this would allow for the ability to type check languages similar to ML\cite{milner1997definition}. 
This is not a required feature but it would greatly expand the scope of what the desired notation would be capable or representing.

The next chapter will discuss the background of type systems and type checkers, along with some previous type checker generators and discuss their advantages and disadvantages.
In \autoref{chap:Method}, the notation for representing type systems will be given, along with the code that we generate from that notation.
The different features in the notation will be expanded upon, examples of how the notation can, and is intended to be, used will then be given.
In \autoref{chap:eval}, it will be discussed whether or not the notation was able to successfully represent and generate code for all of the required features.
Then, there will be a discussion of any potential problems with the notation or with the code that is generated.
Finally any further work that can be done to extend the notation or the code generated will be presented, the possible usefulness of such extensions will also be discussed.
